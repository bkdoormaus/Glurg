"You have made a grave mistake!" - Telos

# An Example of a Practical Use of Glurg
Glurg can be used to quickly extract resources from a game or other software
that uses OpenGL. The important thing is having experience with the OpenGL
version your target software uses, and how common rendering methods are
implemented.

I decided to try it with a game I had easily accessible: RuneScape 3 via the NXT
client.

## Getting started
First, I needed to get a trace file from the game. For this, I used apitrace.

(**Note:** I had to follow the manual tracing method for applications with global
function pointers, like Unigine. See [usage details](https://github.com/apitrace/apitrace/blob/master/docs/USAGE.markdown).)

I briefly looked at the apitrace file in qapitrace. The game made obvious use of
modern OpenGL 3 forward-compatible methods, without any legacy cruft. This means
using only the programmable pipeline, buffers for mesh data, etc.

## Getting vertex attribute names

So with that knowledge, it was time to write a quick heuristic to examine
program usage. This is so I could find the vertex attribute bindings to use with
the built-in GL3StateModelHeuristic.

There was no built-in to print shader information, so I made a heuristic to
print the uniforms and vertex attributes (see /misc/tutorial/heuristics/PrintUniforms.moon).
I ran the heuristic with some target frame in mind:

```
$ ./glurg.sh --trace telos001.trace --heuristic heuristics/PrintUniforms.moon \
  --min-frame=1620 --max-frame=1620 -o output-dir=./models
```

...and examined the output 'attribs' files generated by the heuristic to find
what attributes I need.

The first series of calls only provided vertex positions and some flags:

```
aVertexPosition = 0
aBoneAndLabelAndBatchFlags = 1
```

After examining those calls in qapitrace, it turns out the game is rendering
shadows.

When it begins rendering the world, the amount of attributes jumps:

```
aVertexPosition = 0
aDummy0 = 1
aVertexNormal = 2
aDummy1 = 3
aSpecularFactor = 4
aVertexColour = 5
aTextureUV = 6
aTextureMeta = 7
aSamplerWrapAndTilePosition = 8
aBoneAndLabelAndBatchFlags = 9
```

From here, it's easy to determine what attributes are needed.

## First attempt at extracting meshes

After having attributes, I first started by running the default
GL3StaticModelHeuristic built-in to Glurg, as a starting point:

```
$ ./glurg.sh --trace telos001.trace --heuristic GL3StaticModelHeuristic \
  --min-frame=1620 --max-frame=1620 -o output-dir=./models \
  -o position=aVertexPosition -o normal=aVertexNormal -o texture=aTextureUV \
```

After examining the output, it was evident RuneScape NXT makes gratuitous use of
batching to reduce state changes and draw calls:

![Batched image of some terrain](/images/batch.png?raw=true)

## Extracting sub-meshes

After this, I wrote a simple heuristic to print values from the unknown
vertex attributes 'aTextureMeta', 'aSamplerWrapAndTilePosition', and 
'aBoneAndLabelAndBatchFlags':

```
$ ./glurg.sh --trace telos001.trace --heuristic heuristics/PrintMesh.moon \
  --min-frame=1620 --max-frame=1620 -o output-dir=./models \
  -o position=aVertexPosition -o normal=aVertexNormal -o texture=aTextureUV \
  -o target=aTextureMeta
```

The heuristic inherited from GL3StateModelHeuristic. It overrode 'save_model'.
Upon successfully saving the model, it created a mesh with 'make_mesh' from the
target binding and dumped the values.

After viewing the output, it was evident the data in these is constant per
sub-mesh. For example, in over 11,000 vertices, the data for the example batch
above only had 4 unique values for the aTextureMeta attribute:

```
$ uniq ./models/0004561583.mesh
522.000000, 1024.000000, 32768.000000, 32768.000000
626.000000, 512.000000, 32768.000000, 32768.000000
590.000000, 512.000000, 32768.000000, 32768.000000
522.000000, 1024.000000, 32768.000000, 32768.000000
```

With this knowledge, I could write a custom heuristic to extract meshes
relatively easily, since they are simply stored one after another:

1) Determine unique meshes by iterating over aTextureMeta. The values from this
   attribute are also necessary for texture lookup.
2) Generated sliced meshes, using the ranges extracted in the previous step.
3) Adjust index data to account for new starting index.

This logic is demonstrated in the RS3Model heuristic, which is a giant
modification to GL3StaticModelHeuristic.

But what about textures?

## Tracking the atlas state
RuneScape NXT uses texture giant atlases. I dumped the OpenGL state with
qapitrace/glretrace for a known good state: the draw call for batched terrain
object.

![Texture atlas in use at time](/images/atlas_example.png?raw=true)

By having qapitrace only show texture calls, it became immediately clear the
process:

1) The atlas is created and storage is allocated via glCompressedTexImage2D
2) As needed, images are stored in the atlas via glCompressedTexSubImage2D calls

So I created a texture filter to track calls to glCompressedTexSubImage2D. This
filter--the TextureAtlasFilter--tracks all the textures submitted and creates
glurg.resources.Texture objects out of them. It also provides the means to fetch
the sub-image nearest a point from the atlas.

## Performing atlas lookup
The texture in use by a batched mesh can be determined by the lookup parameters
stored in the 'aTextureMeta' attribute and the atlas parameters stored in the
uniform 'uAtlasMeta'.

The function is pretty simple:

```
get_texture_coords: (texture_meta, atlas_meta) =>
	atlas_slot = math.floor(texture_meta.x + 0.5)
	pixel_size = texture_meta.y
	atlas_slot_size = atlas_meta.x
	atlas_slot_pixel_size = atlas_meta.y
	atlas_pixel_size = atlas_meta.z

	y_slot = math.floor(atlas_slot / atlas_slot_size)
	x_slot = atlas_slot - atlas_slot_size * y_slot

	x = x_slot * atlas_slot_pixel_size
	y = y_slot * atlas_slot_pixel_size

	return x, y
```

The logic is taken from the fragment shader method 'getTexelBias', with a small
modification.

(**Note:** The texture coordinates are further smudged in a method called
'wrapTexCoord', but I only needed the atlas slot. The textures then need cropped
to remove the extra data used during texture wrapping.)

There are two textures bound. I only needed the diffuse texture, which from
referencing the output of the PrintUniforms heuristic to the OpenGL state,
was the texture unit the 'uTextureAtlasPrimary' uniform references.

# End result
After connecting all the dots, the final RS3Model heuristic is actually
pretty simple. It extracts the sub-meshes of a draw call, as well as the
textures from the atlas.

The batched terrain in all its glory, as three separate meshes:
![Batched image of some terrain](/images/batch_final.png?raw=true)

And Telos:
![telos](/images/telos.png?raw=true)
